# LentiMark Algorithm

## Original Paper

This project is inspired by the work presented in the paper
>
> [A visual marker for precise pose estimation based on lenticular
lenses](https://www.semanticscholar.org/paper/Avisual-marker-for-precise-pose-estimation-based-on-Tanaka-Sumi/91929a922171db94660a598b0353438938d84a70)
>
H. Tanaka, Y. Sumi, and Y. Matsumoto, “Avisual marker for precise pose estimation based on lenticular
lenses,” 2012 IEEE International Conference on Robotics and Automation, pp. 5222–5227, 2012.

## Platform Requirements

This project requires Python version 3.0 or above.

## Library Requirements

This project requires the following Python libraries:

- `argparse`: For command-line argument parsing.
- `concurrent.futures`: For concurrent execution using threads or processes.
- `glob`: For file path pattern matching.
- `numpy`: For numerical computations and array manipulations.
- `matplotlib`: For plotting and visualizing data.
- `math`: For mathematical functions and operations.
- `opencv-python` (`cv2`): For image and video processing.
- `pickle`: For object serialization and deserialization.
- `sys`: For interacting with the Python runtime environment.
- `time`: For time-related functions.

### Installation

To install the required libraries, run the following command:

```bash
pip install numpy matplotlib opencv-python
```

The **argparse**, **concurrent.futures**, **glob**, **math**, **pickle**, **sys**, and **time** libraries are typically part of Python's standard library and do not require separate installation.

## Usage

Please follow the instructions below to run the algorithm.

### Step 1: Camera Calibration

**Important:** Whenever you change the camera, it is essential to recalibrate it using the `CalibrateCheckerboard.py` script. This ensures accurate calibration for the new camera.

#### Calibration Instructions:

1. **Obtain the Checkerboard Image:** The checkerboard image required for calibration is included in this repository. The file is named `checkerboard.pdf`.
   
2. **Print the Checkerboard:** You must print the `checkerboard.pdf` image on paper. Ensure that the print is of high quality and the dimensions are accurate to avoid any calibration errors.

3. **Perform the Calibration:** 
   - Place the printed checkerboard on a flat surface.
   - Run the `CalibrateCheckerboard.py` script.
   - Press the "p" key to capture an image of the checkerboard. You need to capture a total of 32 images (this setting can be modified in the code, more is better) of the checkerboard from different angles and distances as shown in the folder `images` (Press the "q" key to quit).
   - The script will use these images to calculate the camera's intrinsic parameters.
   - The calibration data generated by the script will be stored in the file `calibration.pckl` (this setting can be modified in the code) for later use in the project.

Failure to recalibrate the camera after changing it may result in inaccurate measurements or degraded performance of the subsequent algorithms.


### Step 2: Marker Calibration

In order to calibrate a particular marker, you must run the command shown below:
```bash
python Main.py -c True
```
When the program starts, you will receive instructions pasted to the command line. You must place your 
marker in full view of the camera and follow these instructions to calibrate your marker. The program will
collect 30 data points and then quit, storing information in the `angleMap` file. Each line of the `angleMap`
file has the following format:
<Marker_ID> <X_VMP_Slope> <X_VMP_0_degree_position> <Y_VMP_Slope> <Y_VMP_0_degree_position>
This information is used in the detection algorithm to convert black peak position to angle.

### Step 3: Start Detection

To begin the detection process, you must ensure the `config` file contains the IDs of all
markers you would like to detect. Then, execute the following command in your terminal:

```bash
python Main.py
```

the output will be printed in your command line. 

## Individual Files Summary

A little more on what each file is doing

### ArucoSetting.py

- **Marker Type:** Program accepts ArUco markers defined in `ARUCO_DICT`
   - Each entry maps a string name, like `DICT_4X4_50`, to a corresponding OpenCV dictionary constant, like `cv.aruco.DICT_4X4_50`
- **Marker Length:** Specifies physical marker size (24 mm)

### CalibrateCheckerboard.py

```bash 
def photograph():
```

- **Streams Webcam:** Opens webcam video stream
- **User Inputs**
   - Press `q` to quit
   - Press `p` to capture an image of chessboard pattern displayed by webcam
   - Process waits for 16 captures or `q`

```bash
def calibration():
```
**Inputs**

- **Grayscale Conversion:** Reads images and converts to grayscale
- **Detects Chessboard Pattern:** Uses `cv.findChessboardCorners` to find chessboard pattern. If detected:
   - Detected 3D points are added to `objpoints` and 2D points to `imgpoints`
   - Corner point accuracy is refined by `cv.cornerSubPix`
   - Image is displated with highlighted corners
- **Camera Calibration:** camera matrix and distortion coefficients are done by `cv.calibrateCamera`

**Outputs** 

- Calibration data is saved and printed
   - Data (camera matrix, distortion coefficients, rotation, and translational vectors) is saved to `calibration.pckl`

### PnPSolver.py

**Inputs**

- `corners`: Array of detected marker corners for each marker
- `marker_size`: Physical size of the marker in millimeters
- `mtx`: Camera matrix or the intrinsic camera parameters (focal length, optical center, etc)
- `distortion`: Camera distortion coefficients matrix for lens distortion

**Process**

- **Defines Object Points:** Defines `object_points` based on physical marker size to represent corners in 3D space
- **Pose Estimation:** `cv.solvePnP` uses known 3D `object_points` and corresponding 2D `corners` in the image to find:
   - Rotation vector `rvec` for marker orientation
   - Translation vector `tvec` for marker position
   - Note: `cv.SOLVEPNP_IPPE_SQUARE` optimizes pose estimation for square markers

**Outputs**

Rotational vector `R`, translational vector `T`, and 3D coordinates of marker's corners `object_points`

## ReferencePointsDetectionV2.py

## Refinement.py

## Utility.py

## VMPDetectionFxns.py